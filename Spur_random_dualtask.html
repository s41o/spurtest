<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Spurverfolgung – Muster (RMSE, Kurs-Prozente, Geschwindigkeit)</title>
<style>
  :root { --gap:12px; --brand:#111827; --ok:#059669; --bad:#dc2626; }
  *{ box-sizing:border-box; }
  body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:#f7f7f8; color:#111827; }
  .wrap{ max-width:1100px; margin:16px auto; background:#fff; border-radius:16px; padding:16px; box-shadow:0 8px 24px rgba(0,0,0,.08); }
  h1{ margin:0 0 6px; }
  .muted{ color:#6b7280; }
  .row{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin:8px 0 14px; }
  .row label{ display:flex; gap:6px; align-items:center; }
  input[type="text"], input[type="number"], input[type="date"], select{
    padding:8px 10px; border:1px solid #e5e7eb; border-radius:10px; background:#fff;
  }
  .board{ border:1px solid #e5e7eb; border-radius:14px; background:#fff; overflow:hidden; }
  #boardBox{ position:relative; width:100%; height:70vh; min-height:480px; max-height:780px; }
  canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; touch-action:none; }
  .controls{ margin-top:12px; display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
  .btn{ padding:10px 14px; border-radius:10px; border:1px solid #e5e7eb; background:var(--brand); color:#fff; font-weight:600; cursor:pointer; }
  .btn.secondary{ background:#fff; color:#111827; }
  .btn.danger{ background:#fff; color:#dc2626; border-color:#fecaca; }
  .btn.danger:hover{ background:#fee2e2; }
  .btn:disabled{ opacity:.5; cursor:not-allowed; }
  input[type="range"]{ width:180px; padding:0; }
  .pill{ display:inline-block; padding:4px 10px; border-radius:999px; background:#f3f4f6; }
  .legend{ font-size:12px; color:#6b7280; }
  .center{ display:flex; justify-content:center; margin-top:12px; }
  .mono{ font-variant-numeric: tabular-nums; font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; }
  .note{ margin-top:10px; padding:10px; border-radius:10px; background:#eef2ff; color:#1e3a8a; }
  table{ width:100%; border-collapse:collapse; margin-top:12px; }
  th, td{ text-align:left; padding:8px; border-bottom:1px solid #e5e7eb; font-variant-numeric: tabular-nums; }
  th{ background:#f9fafb; }
  .subnote{ font-size:12px; color:#6b7280; }
  progress{ height:10px; width:220px; accent-color: var(--brand); }
</style>
</head>
<body>
<div class="wrap">
  <h1>Spurverfolgung – digital</h1>
  <p class="muted">Ziel: Muster <strong>schnell</strong> und <strong>genau</strong> im Korridor nachfahren. „% innerhalb/außerhalb“ beziehen sich auf die <em>gesamte</em> Kurslänge. Start beim <strong>grünen Punkt</strong> (nach Start lila).</p>

  <!-- Metadaten -->
  <div class="row">
    <label> Name <input id="metaName" type="text" placeholder="Name" /></label>
    <label> Codenummer <input id="metaCode" type="text" placeholder="Code" /></label>
    <label> Messzeitpunkt <input id="metaWhenNum" type="number" placeholder="z. B. 1" /></label>
    <label> Trainingseinheit <input id="metaUnit" type="text" placeholder="z. B. TE-3" /></label>
    <label> Datum <input id="metaDate" type="date" /></label>
  </div>

  <!-- Anzeige-/Geschwindigkeitskalibrierung -->
  <div class="row">
    <label>Auflösung (px)
      <input id="scrW" type="number" placeholder="Breite" style="width:100px" />
      ×
      <input id="scrH" type="number" placeholder="Höhe" style="width:100px" />
    </label>
    <label>Diagonale (Zoll)
      <input id="scrDiag" type="number" step="0.1" placeholder="z. B. 20" style="width:100px" />
    </label>
    <span class="subnote mono" id="dpiInfo">dpi: — · px/cm: —</span>
  </div>

  <!-- Controls (über dem Muster) -->
  <div class="controls">
    <label>Muster
      <select id="pattern" disabled>
        <option value="spiral">1 · Spirale (5 Windungen)</option>
        <option value="square_triangle">2 · Viereck + Dreieck</option>
        <option value="circle">3 · Kreis</option>
        <option value="zigzag">4 · Zickzack</option>
        <option value="sine_snake">5 · Sinus (Schlangenlinie)</option>
        <option value="figure8">6 · Acht (∞)</option>
        <option value="star">7 · Stern (zackig)</option>
        <option value="clover">8 · Kleeblatt</option>
        <option value="switchbacks">9 · Kehren (U-Kurs)</option>
        <option value="shapes_combo">10 · Formmix (rund + eckig)</option>
        <option value="square">11 · Formmix (rund + „Treppen“)</option>
      </select>
    </label>

    <label>Korridor <span id="wLabel" class="mono">28 px</span>
      <input type="range" id="width" min="8" max="40" step="2" value="28" />
    </label>

<label>Zahlensequenz-Länge 
  <input type="number" id="seqLength" min="4" max="7" value="5" style="width:60px" />
</label>

    <label><input type="checkbox" id="showFeedback" checked /> Feedback anzeigen</label>
    <button class="btn secondary" id="reset">Zurücksetzen</button>
    <button class="btn danger" id="resetAll">Training vollständig zurücksetzen</button>
    <button class="btn" id="exportCsv">CSV exportieren</button>
    <span class="pill" id="status">Bereit</span>
  </div>

  <!-- Fortschritt -->
  <div class="row">
    <span class="pill">Fortschritt: <span id="runCount" class="mono">0</span>/<span class="mono">110</span></span>
    <progress id="runProgress" value="0" max="110"></progress>
    <span class="subnote">Aktuelles Muster: <strong id="currentPatternName">—</strong> · Nächstes: <strong id="nextPatternName">—</strong></span>
  </div>

  <!-- Zeichenfläche -->
  <div class="board">
    <div id="boardBox">
      <canvas id="cv"></canvas>
    </div>
  </div>

  <!-- Weiter-Button -->
  <div class="center">
    <button class="btn" id="nextBtn" disabled>Nächstes Muster</button>
  </div>

  <div class="legend">Fehler = RMSE über <em>max(0, Abstand zur Mittellinie − halbe Korridorbreite)</em>.</div>

  <!-- Aktuelles Ergebnis -->
  <h3 style="margin-top:18px;">Aktuelles Ergebnis</h3>
  <div id="currentResult" class="note">Noch kein Durchgang.</div>

  <!-- Gesamtstatistik -->
  <h3 style="margin-top:18px;">Gesamtstatistik je Muster</h3>
  <table id="statsTable">
    <thead>
      <tr>
        <th>Muster</th><th>Durchg.</th><th>Letzter RMSE</th><th>Letzte Zeit</th><th>Letzte Fehler</th>
        <th>Bester RMSE</th><th>Ø RMSE</th><th>Ø Außerhalb</th><th>Ø Innerhalb</th><th>Ø Zeit</th><th>Ø Fehler</th><th>Ø Speed (cm/s)</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<script>
/* ====================== BACKEND (Google Sheets) ======================= */
// Trage hier deine Apps-Script Web-App URL (…/exec) ein:
const BACKEND_URL = 'https://script.google.com/macros/s/AKfycbzEa4Abfk-3InFoW-8NRdNLzWA9sumdtPH1wEY8f__OM-VdjbLpu6aBxYRkKxw5tBvueQ/exec';
// Optional: gemeinsames Secret; wenn gesetzt, wird es als "secret" mitgesendet
const BACKEND_SECRET = '';
function getBackendConfig(){ return { url:(BACKEND_URL||'').trim(), secret:(BACKEND_SECRET||'').trim() }; }
function collectPayload(){
  const info = getDpiInfo();
  const total = state.startTime ? ((state.endTime ?? performance.now()) - state.startTime) : '';
  return {
    timestamp_iso: new Date().toISOString(),
    name: (document.getElementById('metaName').value||'').replace(/,/g,' '),
    code: (document.getElementById('metaCode').value||'').replace(/,/g,' '),
    when_num: (document.getElementById('metaWhenNum').value||''),
    unit: (document.getElementById('metaUnit').value||'').replace(/,/g,' '),
    date: (document.getElementById('metaDate').value||''),
    pattern: state.pattern,
    seed: state.seed,
    corridor_px: state.corridorPx,
    rmse_px: state.rmse ?? '',
    outside_pct_course: state.outsidePct ?? '',
    inside_pct_course: state.insidePct ?? '',
    avg_speed_cm_s: state.avgSpeedCmS ?? '',
    total_time_ms: total ? Number(total.toFixed(1)) : '',
    error_count: state.errorCount ?? '',
    px_per_cm: state.pxPerCm ?? info?.pxPerCm ?? '',
    dpi: info?.dpi ?? '',
    scr_w: info?.w ?? '',
    scr_h: info?.h ?? '',
    scr_diag_in: info?.diag ?? '',
    // optional
    secret: getBackendConfig().secret || undefined,
 seq_correct: state.sequence?.correct ?? '',
    seq_entered: state.sequence?.entered ?? '',
    seq_result: state.sequence?.result ?? '',
  };
}
async function sendToBackend(){
  const { url } = getBackendConfig();
  if (!url){ setStatus('Bitte BACKEND_URL (Apps Script exec) eintragen.'); return; }
  if (state.rmse == null){ setStatus('Noch kein Ergebnis zum Senden.'); return; }
  setStatus('Sende …');
  try{
    const payload = collectPayload();
    const body = new URLSearchParams(Object.entries(payload).reduce((acc,[k,v])=>{ acc[k]=String(v==null?'':v); return acc; },{})).toString();
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type':'application/x-www-form-urlencoded;charset=UTF-8' },
      body,
      mode: 'cors'
    });
    let data={}; try{ data = await res.json(); }catch{}
    if (res.ok && (data?.ok===true || data?.result==='ok')){
      setStatus('Gesendet' + (data?.insertedRow? (' (Zeile '+data.insertedRow+')') : ''));
    } else {
      setStatus('Fehler beim Senden');
      console.error('Backend error', data);
      alert('Fehler vom Backend: '+JSON.stringify(data||{}));
    }
  } catch(err){
    setStatus('Netzwerk-/CORS-Fehler');
    console.error(err);
    alert('Netzwerk-/CORS-Fehler: '+err);
  }
}

/* =========================== CONFIG/PROGRESS =========================== */
const TOTAL_RUNS=110, RUN_PLAN_KEY='spur_run_plan_v2_fixed', RUN_INDEX_KEY='spur_run_index_v2_fixed';
const patternOrder=['spiral','square_triangle','circle','zigzag','sine_snake','figure8','star','clover','switchbacks','shapes_combo','square'];
const patternName={spiral:'Spirale',square_triangle:'Viereck + Dreieck',circle:'Kreis',zigzag:'Zickzack',sine_snake:'Sinus (Schlangenlinie)',figure8:'Acht',star:'Stern',clover:'Kleeblatt',switchbacks:'Kehren',shapes_combo:'Formmix (rund + eckig)',square:'Formmix (rund + „Treppen“)'};
let runPlan=[], runIndex=0;

/* Zufälliger Plan: alle 110 Durchgänge zufällig gemischt */
function buildRunPlan(){
  const arr=[];
  // 10 Wiederholungen pro Muster, wie bisher
  for (const p of patternOrder){
    for (let i=0;i<10;i++) arr.push(p);
  }
  // Fisher–Yates-Shuffle für echte Zufälligkeit
  for (let i=arr.length-1; i>0; i--){
    const j = Math.floor(Math.random() * (i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function saveProgress(){ try{localStorage.setItem(RUN_PLAN_KEY,JSON.stringify(runPlan));}catch{} try{localStorage.setItem(RUN_INDEX_KEY,String(runIndex));}catch{} }
function loadProgress(){
  runPlan = buildRunPlan(); // immer den geblockten Plan erzwingen
  try{
    const idx=parseInt(localStorage.getItem(RUN_INDEX_KEY)||'0',10);
    runIndex=isFinite(idx)?Math.min(Math.max(0,idx),TOTAL_RUNS-1):0;
  }catch{ runIndex=0; }
  saveProgress();
}
function updateProgressUI(){
  document.getElementById('runCount').textContent=String(runIndex);
  document.getElementById('runProgress').value=runIndex;
  const cur=runPlan[runIndex]||'—', nxt=runPlan[runIndex+1]||'—';
  document.getElementById('currentPatternName').textContent=patternName[cur]||cur;
  document.getElementById('nextPatternName').textContent=patternName[nxt]||(runIndex+1>=TOTAL_RUNS?'— (fertig)':'—');
}

/* ================================ UTILS ================================ */
const DPR=window.devicePixelRatio||1;
function fmtMs(ms){ if(!isFinite(ms))return'00:00.000'; const m=Math.floor(ms/60000),s=Math.floor((ms%60000)/1000),ms3=Math.floor(ms%1000); return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(ms3).padStart(3,'0')}`; }
function lerp(a,b,t){return a+(b-a)*t} function dist(a,b){const dx=a.x-b.x,dy=a.y-b.y;return Math.hypot(dx,dy)} function clamp(v,lo,hi){return Math.max(lo,Math.min(hi,v))}
const SEP=';'; function csvQuote(s){ return `"${String(s).replace(/"/g,'""')}"`; }
function deDec(v,d){ if(v==null||v===''||!isFinite(v)) return ''; const n=(d!=null)?Number(v).toFixed(d):String(v); return n.replace('.',','); }

/* =============================== CANVAS ================================ */
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
function resizeCanvas(){
  const r=cv.getBoundingClientRect();
  const w=Math.max(1,Math.round(r.width*DPR));
  const h=Math.max(1,Math.round(r.height*DPR));
  if (cv.width!==w) cv.width=w;
  if (cv.height!==h) cv.height=h;
}
window.addEventListener('resize',()=>{ resizeCanvas(); buildCourse(false); draw(); });

/* =============================== STATE ================================= */
let state={ seed:(Math.random()*1e9)|0, pattern:'spiral', corridorPx:28, centerline:[], start:null, finish:null, drawing:false, started:false, trace:[], startTime:null, endTime:null, rmse:null, outsidePct:null, insidePct:null, errorCount:null, avgSpeedCmS:null, pxPerCm:null };
const perPatternStats=new Map();
const allRuns=[];

/* =========================== GEOMETRY HELPERS ========================== */
function polyLength(p){let L=0;for(let i=1;i<p.length;i++)L+=dist(p[i-1],p[i]);return L;}
function resample(poly,n){const L=polyLength(poly); if(L===0) return poly.slice(0,1); const out=[poly[0]]; let seg=1,dAcc=0; for(let k=1;k<n;k++){ const target=(k/(n-1))*L; while(seg<poly.length&&dAcc+dist(poly[seg-1],poly[seg])<target){ dAcc+=dist(poly[seg-1],poly[seg]); seg++; } if(seg>=poly.length){ out.push(poly[poly.length-1]); continue; } const a=poly[seg-1],b=poly[seg],rem=target-dAcc,ab=dist(a,b),t=ab?(rem/ab):0; out.push({x:lerp(a.x,b.x,t),y:lerp(a.y,b.y,t)});} return out;}
function pointSegDist(p,a,b){const abx=b.x-a.x,aby=b.y-a.y;const apx=p.x-a.x,apy=p.y-a.y;const ab2=abx*abx+aby*aby;const t=ab2?clamp((apx*abx+apy*aby)/ab2,0,1):0;const x=a.x+abx*t,y=a.y+aby*t;return{d:Math.hypot(p.x-x,p.y-y)}}
function pointPolylineDist(p,poly){let best=Infinity;for(let i=1;i<poly.length;i++){const r=pointSegDist(p,poly[i-1],poly[i]);if(r.d<best)best=r.d;}return best;}
function fitAndCenter(pts,W,H,pad){let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=Infinity*-1;for(const p of pts){if(p.x<minX)minX=p.x;if(p.y<minY)minY=p.y;if(p.x>maxX)maxX=p.x;if(p.y>maxY)maxY=p.y;}const bw=maxX-minX||1,bh=maxY-minY||1;const s=Math.min((W-2*pad)/bw,(H-2*pad)/bh);const offX=(W-bw*s)/2-minX*s,offY=(H-bh*s)/2-minY*s;return pts.map(p=>({x:p.x*s+offX,y:p.y*s+offY}))}
function isClosedPattern(n){return n==='circle'||n==='figure8'||n==='star'||n==='clover'}

/* =========================== PATTERN GEN =============================== */
function genPattern(name,W,H){
  const pad=48*DPR, w=Math.max(100,W-2*pad), h=Math.max(100,H-2*pad), cx=pad+w/2, cy=pad+h/2, baseR=Math.min(w,h)*0.45;
  const pts=[], add=(x,y)=>pts.push({x,y});
  if(name==='spiral'){ const turns=5,steps=1000,b=(baseR*0.95)/(turns*Math.PI); for(let i=0;i<steps;i++){ const t=i/steps*turns*2*Math.PI,r=b*t; add(cx+r*Math.cos(t),cy+r*Math.sin(t)); } }
  else if(name==='square_triangle'){ const cols=8,rows=6,gridW=w*0.9,gridH=h*0.7,x0=cx-gridW/2,y0=cy-gridH/2,dx=gridW/cols,dy=gridH/rows; let y=y0,dir=1; for(let r=0;r<=rows;r++){ const xStart=dir>0?x0:x0+gridW,xEnd=dir>0?x0+gridW:x0; for(let x=xStart;(dir>0?x<=xEnd:x>=xEnd);x+=dir*dx){ add(x,y); const up=((r+Math.round((x-x0)/dx))%2)===0, tipY=Math.max(pad,Math.min(pad+h,y+(up?-dy*0.60:dy*0.60))); add(x+dx*0.5*dir,tipY); add(x+dx*dir,y); } if(r<rows){ y+=dy; add(xEnd,y);} dir*=-1; } }
  else if(name==='circle'){ const steps=800,R=baseR; for(let i=0;i<=steps;i++){ const t=i/steps*2*Math.PI; add(cx+R*Math.cos(t),cy+R*Math.sin(t)); } }
  else if(name==='zigzag'){ const peaks=12,A=h*0.35,yMid=cy; for(let i=0;i<=peaks;i++){ const t=i/peaks,x=pad+t*w,y=yMid+(i%2===0?-A:A); add(x,y);} }
  else if(name==='sine_snake'){ const lanes=4,periods=5,steps=700,rowH=h/lanes,A=rowH*0.48; for(let k=0;k<lanes;k++){ const yC=pad+(k+0.5)*rowH,leftToRight=(k%2===0); for(let i=0;i<=steps;i++){ const t=i/steps,x=pad+(leftToRight?t:(1-t))*w,y=yC+A*Math.sin(t*periods*2*Math.PI+k*0.5); add(x,y);} if(k<lanes-1){ const xConn=leftToRight?(pad+w):pad; add(xConn,yC); add(xConn,pad+(k+1+0.5)*rowH);} } }
  else if(name==='figure8'){ const steps=900,a=baseR*0.8; for(let i=0;i<=steps;i++){ const t=(i/steps)*2*Math.PI,s=Math.sin(t),c=Math.cos(t),d=1+s*s; add(cx+(a*Math.sqrt(2)*c)/d,cy+(a*Math.sqrt(2)*c*s)/d);} }
  else if(name==='star'){ const spikes=6,steps=spikes*2,r1=baseR,r2=baseR*0.45; for(let i=0;i<=steps;i++){ const t=i/steps*2*Math.PI,r=(i%2===0)?r1:r2; add(cx+r*Math.cos(t),cy+r*Math.sin(t)); } }
  else if(name==='clover'){ const steps=900,a=baseR*0.9,k=4; for(let i=0;i<=steps;i++){ const t=i/steps*2*Math.PI,r=a*Math.sin(k*t)*(1+0.06*Math.sin(7*t)); add(cx+r*Math.cos(t),cy+r*Math.sin(t)); } }
  else if(name==='switchbacks'){ const cols=12; for(let i=0;i<=cols;i++){ const x=pad+(w*i/cols),y0=pad,y1=pad+h; if(i%2===0){ add(x,y0); add(x,y1);} else { add(x,y1); add(x,y0);} } }
  else if(name==='shapes_combo'||name==='square'){ const lanes=6,rowH=h/lanes,A=rowH*0.48,periods=6,steps=600; const tri=x=>{const u=x-Math.floor(x);return 1-4*Math.abs(u-0.5)}, softSquare=x=>{const k=3.5;return Math.tanh(k*Math.sin(2*Math.PI*x))}; function roundRow(k,ltr){const yC=pad+(k+0.5)*rowH; for(let i=0;i<=steps;i++){ const t=i/steps,x=pad+(ltr?t:(1-t))*w,y=yC+A*(0.78*Math.sin(t*periods*2*Math.PI+k*0.4)+0.22*Math.sin(t*(periods*1.7)*2*Math.PI+k*0.9)); add(x,y);} } function stairRow(k,ltr){const yC=pad+(k+0.5)*rowH; for(let i=0;i<=steps;i++){ const t=i/steps,x=pad+(ltr?t:(1-t))*w,y=yC+A*(0.65*tri(periods*t)+0.35*softSquare(periods*t)); add(x,y);} } for(let k=0;k<lanes;k++){ const ltr=(k%2===0); if(k%2===0) roundRow(k,ltr); else stairRow(k,ltr); if(k<lanes-1){ const xConn=ltr?(pad+w):pad; add(xConn,pad+(k+0.5)*rowH); add(xConn,pad+(k+1+0.5)*rowH);} } }
  const fitted=fitAndCenter(pts,W,H,48*DPR); return {pts:fitted,start:fitted[0],finish:fitted[fitted.length-1]};
}

/* ============================ COURSE/DRAW ============================== */
function buildCourse(newSeed=true){
  if(newSeed) state.seed=(Math.random()*1e9)|0;
  const W=cv.width,H=cv.height;
  if (W<2 || H<2) return; // Sicherheit: erst zeichnen wenn Canvas Größe hat
  const g=genPattern(state.pattern,W,H);
  state.centerline=g.pts; state.start=g.start; state.finish=g.finish;
  state.trace=[]; state.started=false; state.startTime=null; state.endTime=null;
  state.rmse=null; state.outsidePct=null; state.insidePct=null; state.errorCount=null; state.avgSpeedCmS=null;
  document.getElementById('nextBtn').disabled=true;
  setStatus('Bereit'); document.getElementById('currentResult').textContent='Noch kein Durchgang.';
  draw();
}
function draw(){
  const W=cv.width,H=cv.height;
  ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,W,H);
  if(state.centerline.length<=1){
    ctx.fillStyle='#6b7280'; ctx.font=`${14*DPR}px system-ui,-apple-system,Segoe UI,Roboto`;
    ctx.fillText('Lade Muster …',16*DPR,24*DPR);
    return;
  }
  ctx.lineCap='round'; ctx.lineJoin='round';
  ctx.lineWidth=Math.max(4,state.corridorPx)*DPR; ctx.strokeStyle='#cbd5e1';
  ctx.beginPath(); ctx.moveTo(state.centerline[0].x,state.centerline[0].y);
  for(let i=1;i<state.centerline.length;i++) ctx.lineTo(state.centerline[i].x,state.centerline[i].y);
  ctx.stroke();
  ctx.lineWidth=2*DPR; ctx.strokeStyle='#334155'; ctx.setLineDash([6*DPR,6*DPR]);
  ctx.beginPath(); ctx.moveTo(state.centerline[0].x,state.centerline[0].y);
  for(let i=1;i<state.centerline.length;i++) ctx.lineTo(state.centerline[i].x,state.centerline[i].y);
  ctx.stroke(); ctx.setLineDash([]);
  if(isClosedPattern(state.pattern)){
    ctx.fillStyle=state.started?'#8b5cf6':'#10b981';
    ctx.beginPath(); ctx.arc(state.start.x,state.start.y,10*DPR,0,Math.PI*2); ctx.fill();
  }else{
    ctx.fillStyle='#10b981'; ctx.beginPath(); ctx.arc(state.start.x,state.start.y,10*DPR,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#8b5cf6'; ctx.beginPath(); ctx.arc(state.finish.x,state.finish.y,10*DPR,0,Math.PI*2); ctx.fill();
  }
  if(state.trace.length>1){
    ctx.lineWidth=3*DPR; ctx.strokeStyle='#111827';
    ctx.beginPath(); ctx.moveTo(state.trace[0].x,state.trace[0].y);
    for(let i=1;i<state.trace.length;i++) ctx.lineTo(state.trace[i].x,state.trace[i].y);
    ctx.stroke();
  }
  if(document.getElementById('showFeedback').checked && state.trace.length>2){
    const halfW=state.corridorPx/2*DPR; const sample=resample(state.trace,220);
    for(const p of sample){
      const d=pointPolylineDist(p,state.centerline); const e=Math.max(0,d-halfW);
      if(e>0){ const alpha=clamp(e/(halfW*1.5),0.12,0.9); ctx.fillStyle=`rgba(220,38,38,${alpha})`; ctx.beginPath(); ctx.arc(p.x,p.y,4*DPR,0,Math.PI*2); ctx.fill(); }
    }
  }
}

/* ============================ METRICS & UI ============================ */
function computeMetrics(){
  if(!state.trace.length||!state.centerline.length||!state.startTime||!state.endTime) return;
  const halfW=state.corridorPx/2*DPR;
  const M=900,C=resample(state.centerline,M); let insideLen=0,totalLen=0;
  for(let i=1;i<C.length;i++){
    const a=C[i-1],b=C[i],segLen=dist(a,b); if(segLen<=0) continue; totalLen+=segLen;
    const mid={x:(a.x+b.x)/2,y:(a.y+b.y)/2}; const dToTrace=pointPolylineDist(mid,state.trace);
    if(dToTrace<=halfW) insideLen+=segLen;
  }
  state.insidePct=totalLen>0?(insideLen/totalLen)*100:0; state.outsidePct=100-(state.insidePct||0);
  let sumLen=0,sumW2L=0,errorCount=0,prevOutside=null;
  for(let i=1;i<state.trace.length;i++){
    const a=state.trace[i-1],b=state.trace[i],segLen=dist(a,b); if(segLen<=0) continue; sumLen+=segLen;
    const mid={x:(a.x+b.x)/2,y:(a.y+b.y)/2}; const dMid=pointPolylineDist(mid,state.centerline);
    const eMid=Math.max(0,dMid-halfW); const outside=eMid>0; if(prevOutside===false&&outside===true) errorCount++;
    sumW2L+=(eMid*eMid)*segLen; prevOutside=outside;
  }
  state.rmse=(sumLen>0)?Math.sqrt(sumW2L/sumLen)/DPR:0; state.errorCount=errorCount;
  const pxPerCm=getPxPerCm(); const centerLenPx=polyLength(state.centerline), centerLenCm=pxPerCm?(centerLenPx/pxPerCm):0, totalSec=(state.endTime-state.startTime)/1000;
  state.avgSpeedCmS=(totalSec>0&&centerLenCm>0)?(centerLenCm/totalSec):0;
}
const statusEl=document.getElementById('status'); function setStatus(t){statusEl.textContent=t;}
function renderCurrentResult(){
  const box=document.getElementById('currentResult');
  if(state.rmse==null){ box.textContent='Noch kein Durchgang.'; return; }
  const total=state.startTime?((state.endTime??performance.now())-state.startTime):0;
  box.innerHTML=`<strong>${patternName[state.pattern]||state.pattern}</strong>:
    RMSE <span class="mono">${state.rmse.toFixed(2)} px</span> ·
    Außerhalb <span class="mono">${state.outsidePct.toFixed(1)}%</span> ·
    <strong>Innerhalb</strong> <span class="mono">${state.insidePct.toFixed(1)}%</span> ·
    Zeit <span class="mono">${fmtMs(total)}</span> ·
    Fehler <span class="mono">${state.errorCount}</span> ·
    Speed <span class="mono">${state.avgSpeedCmS?.toFixed(2)} cm/s</span> ·
    Seed <span class="mono">${state.seed}</span>`;
}
function updatePerPatternStats(){
  const total=state.startTime?((state.endTime??performance.now())-state.startTime):0;
  if(state.rmse==null) return;
  const info=getDpiInfo();
allRuns.push({
  timestamp_iso:new Date().toISOString(),
  name:(document.getElementById('metaName').value||''),
  code:(document.getElementById('metaCode').value||''),
  when_num:(document.getElementById('metaWhenNum').value||''),
  unit:(document.getElementById('metaUnit').value||''),
  date:(document.getElementById('metaDate').value||''),
  pattern:state.pattern, seed:state.seed, corridor_px:state.corridorPx,
  rmse_px:state.rmse, outside_pct_course:state.outsidePct, inside_pct_course:state.insidePct,
  avg_speed_cm_s:state.avgSpeedCmS, total_time_ms: total?Number(total.toFixed(1)):0, error_count:state.errorCount||0,
  px_per_cm: state.pxPerCm ?? info?.pxPerCm ?? null,
  dpi: info?.dpi ?? null, scr_w: info?.w ?? null, scr_h: info?.h ?? null, scr_diag_in: info?.diag ?? null,
  seq_correct: state.sequence?.correct ?? '',      // <-- NEU
  seq_entered: state.sequence?.entered ?? '',      // <-- NEU
  seq_result:  state.sequence?.result ?? ''        // <-- NEU
});

  const key=state.pattern;
  const cur=perPatternStats.get(key)||{n:0,sumRmse:0,bestRmse:Infinity,lastRmse:null,lastTime:0,sumOutside:0,sumInside:0,sumTime:0,sumErrors:0,lastErrors:0,sumSpeedCmS:0};
  cur.n+=1; cur.sumRmse+=state.rmse; cur.lastRmse=state.rmse; cur.lastTime=total; cur.lastErrors=state.errorCount||0; cur.bestRmse=Math.min(cur.bestRmse,state.rmse);
  cur.sumOutside+=(state.outsidePct||0); cur.sumInside+=(state.insidePct||0); cur.sumTime+=total||0; cur.sumErrors+=(state.errorCount||0); cur.sumSpeedCmS+=(state.avgSpeedCmS||0);
  perPatternStats.set(key,cur);
  renderStatsTable();
}
function renderStatsTable(){
  const tbody=document.querySelector('#statsTable tbody'); tbody.innerHTML='';
  for(const key of patternOrder){
    const s=perPatternStats.get(key); if(!s) continue;
    const avgRmse=s.sumRmse/s.n, avgOut=s.sumOutside/s.n, avgIn=s.sumInside/s.n, avgTime=s.sumTime/s.n, avgErr=s.sumErrors/s.n, avgSpeed=s.sumSpeedCmS/s.n;
    const tr=document.createElement('tr');
    tr.innerHTML=`
      <td>${patternName[key]||key}</td>
      <td class="mono">${s.n}</td>
      <td class="mono">${s.lastRmse?.toFixed(2)??'—'}</td>
      <td class="mono">${fmtMs(s.lastTime||0)}</td>
      <td class="mono">${s.lastErrors??0}</td>
      <td class="mono">${isFinite(s.bestRmse)?s.bestRmse.toFixed(2):'—'}</td>
      <td class="mono">${avgRmse.toFixed(2)}</td>
      <td class="mono">${avgOut.toFixed(1)}%</td>
      <td class="mono">${avgIn.toFixed(1)}%</td>
      <td class="mono">${fmtMs(avgTime)}</td>
      <td class="mono">${avgErr.toFixed(2)}</td>
      <td class="mono">${avgSpeed.toFixed(2)}</td>`;
    tbody.appendChild(tr);
  }
}

/* ============================== CSV EXPORT ============================= */
function buildRunsCsvSection(){
  // Spaltenüberschriften (inkl. Sequenzdaten)
  const header=[
    'timestamp_iso','name','code','when_num','unit','date',
    'pattern','seed','corridor_px','rmse_px',
    'outside_pct_course','inside_pct_course',
    'avg_speed_cm_s','total_time_ms','error_count',
    'px_per_cm','dpi','scr_w','scr_h','scr_diag_in',
    'seq_correct','seq_entered','seq_result'   // <-- HIER NEU
  ];
  const lines=[header.join(SEP)];

  for(const r of allRuns){
    const row=[
      r.timestamp_iso, csvQuote(r.name), csvQuote(r.code),
      r.when_num??'', csvQuote(r.unit), r.date??'',
      r.pattern, r.seed??'', r.corridor_px??'',
      deDec(r.rmse_px,2), deDec(r.outside_pct_course,1), deDec(r.inside_pct_course,1),
      deDec(r.avg_speed_cm_s,2), r.total_time_ms??'', r.error_count??'',
      deDec(r.px_per_cm,5), deDec(r.dpi,2), r.scr_w??'', r.scr_h??'', deDec(r.scr_diag_in,2),
      csvQuote(r.seq_correct??''), csvQuote(r.seq_entered??''), csvQuote(r.seq_result??'') // <-- HIER NEU
    ];
    lines.push(row.join(SEP));
  }
  return lines.join('\n');
}

function buildStatsCsvSection(){
  const header=['pattern_key','pattern_name','runs','last_rmse_px','last_time_ms','last_errors','best_rmse_px','avg_rmse_px','avg_outside_pct','avg_inside_pct','avg_time_ms','avg_errors','avg_speed_cm_s'];
  const lines=[header.join(SEP)];
  for(const key of patternOrder){
    const s=perPatternStats.get(key); if(!s) continue;
    const avgRmse=s.sumRmse/s.n, avgOut=s.sumOutside/s.n, avgIn=s.sumInside/s.n, avgTime=s.sumTime/s.n, avgErr=s.sumErrors/s.n, avgSpeed=s.sumSpeedCmS/s.n;
    const row=[
      key, csvQuote(patternName[key]||key), s.n,
      deDec(isFinite(s.lastRmse)?Number(s.lastRmse.toFixed(2)):null,2),
      isFinite(s.lastTime)?Number(s.lastTime.toFixed(1)):'',
      isFinite(s.lastErrors)?s.lastErrors:'',
      deDec(isFinite(s.bestRmse)?Number(s.bestRmse.toFixed(2)):null,2),
      deDec(isFinite(avgRmse)?Number(avgRmse.toFixed(2)):null,2),
      deDec(isFinite(avgOut)?Number(avgOut.toFixed(1)):null,1),
      deDec(isFinite(avgIn)?Number(avgIn.toFixed(1)):null,1),
      isFinite(avgTime)?Number(avgTime.toFixed(1)):'',
      deDec(isFinite(avgErr)?Number(avgErr.toFixed(2)):null,2),
      deDec(isFinite(avgSpeed)?Number(avgSpeed.toFixed(2)):null,2)
    ];
    lines.push(row.join(SEP));
  }
  return lines.join('\n');
}
function exportCSV(){
  const runs=buildRunsCsvSection();
  const stats=buildStatsCsvSection();
  const csv='sep=;\n'+runs+'\n\n'+stats+'\n';
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
  a.download=`Spur_Export_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
  document.body.appendChild(a); a.click(); a.remove();
}

/* =============================== CALIBRATION =========================== */
function getDpiInfo(){ const w=parseFloat(document.getElementById('scrW').value); const h=parseFloat(document.getElementById('scrH').value); const d=parseFloat(document.getElementById('scrDiag').value); if(!isFinite(w)||!isFinite(h)||!isFinite(d)||w<=0||h<=0||d<=0) return null; const dpi=Math.sqrt(w*w+h*h)/d; const pxPerCm=dpi/2.54; return {dpi,pxPerCm,w,h,diag:d}; }
function updatePxPerCm(){ const info=getDpiInfo(); const lbl=document.getElementById('dpiInfo'); if(info){ state.pxPerCm=info.pxPerCm; lbl.textContent=`dpi: ${info.dpi.toFixed(2)} · px/cm: ${info.pxPerCm.toFixed(2)}`; } else { state.pxPerCm=null; lbl.textContent='dpi: — · px/cm: —'; } }
function getPxPerCm(){ if(state.pxPerCm==null){ const info=getDpiInfo(); if(info) state.pxPerCm=info.pxPerCm; } return state.pxPerCm||0; }
['scrW','scrH','scrDiag'].forEach(id=>document.getElementById(id).addEventListener('input',updatePxPerCm));

/* ================================ FLOW ================================= */
function canvasPosFromEvent(e){ const r=cv.getBoundingClientRect(); return {x:(e.clientX-r.left)*DPR,y:(e.clientY-r.top)*DPR}; }
cv.addEventListener('pointerdown',e=>{ cv.setPointerCapture(e.pointerId); const p=canvasPosFromEvent(e); const tol=12*DPR; if(!state.started&&state.start&&dist(p,state.start)<=tol){ state.started=true; state.startTime=performance.now(); } state.drawing=true; state.trace.push({x:p.x,y:p.y,t:performance.now()}); draw(); });
cv.addEventListener('pointermove',e=>{ if(!state.drawing)return; const p=canvasPosFromEvent(e); state.trace.push({x:p.x,y:p.y,t:performance.now()}); draw(); });
['pointerup','pointercancel','pointerleave'].forEach(ev=>cv.addEventListener(ev,e=>{ state.drawing=false; try{cv.releasePointerCapture(e.pointerId);}catch{} }));
cv.addEventListener('pointerup',e=>{
  if(!state.finish||state.trace.length<6||!state.started) return;
  const p=canvasPosFromEvent(e), tol=12*DPR;
  if(dist(p,state.finish)<=tol){
    state.endTime=performance.now(); computeMetrics(); renderCurrentResult(); draw();
    setStatus('Fertig – „Nächstes Muster“ drücken'); updatePerPatternStats(); document.getElementById('nextBtn').disabled=false;
  }
});
const patternSel=document.getElementById('pattern');
document.getElementById('reset').addEventListener('click',()=>buildCourse(true));
document.getElementById('exportCsv').addEventListener('click',exportCSV);
document.getElementById('width').addEventListener('input',e=>{ state.corridorPx=parseFloat(e.target.value); document.getElementById('wLabel').textContent=`${Math.round(state.corridorPx)} px`; draw(); });
document.getElementById('nextBtn').addEventListener('click',async()=>{
  // Beim Wechsel: erst an Google Sheets senden (falls URL hinterlegt und Ergebnis vorhanden)
  if (state.rmse != null && (BACKEND_URL||'').trim()){
    await sendToBackend();
  }
  runIndex++; saveProgress(); updateProgressUI();
  if(runIndex>=TOTAL_RUNS){ setStatus('Alle 110 Durchgänge abgeschlossen.'); document.getElementById('nextBtn').disabled=true; return; }
  const next=runPlan[runIndex]; patternSel.value=next; state.pattern=next; buildCourse(true);
});
document.getElementById('resetAll').addEventListener('click',()=>{
  if(!confirm('⚠️ Training wirklich vollständig zurücksetzen?')) return;
  const phrase=prompt('Zur Bestätigung bitte exakt "RESET" eingeben:'); if(phrase!=='RESET'){ alert('Abgebrochen.'); return; }
  try{localStorage.removeItem(RUN_PLAN_KEY);}catch{} try{localStorage.removeItem(RUN_INDEX_KEY);}catch{}
  try{localStorage.removeItem('spur_run_plan_v1');}catch{} try{localStorage.removeItem('spur_run_index_v1');}catch{}
  try{perPatternStats.clear();}catch{} allRuns.length=0;
  const tbody=document.querySelector('#statsTable tbody'); if(tbody) tbody.innerHTML='';
  runPlan=buildRunPlan(); runIndex=0; saveProgress();
  const first=runPlan[0]; patternSel.value=first; state.pattern=first;
  buildCourse(true); updateProgressUI(); setStatus('Bereit (neu gestartet)'); alert('Training wurde vollständig zurückgesetzt.');
});

/* ================================= INIT ================================ */
function init(){
  loadProgress();
  // Nach Layout berechnen: erst Canvas richtig dimensionieren, dann Kurs aufbauen
  requestAnimationFrame(()=>{
    resizeCanvas();
    const cur=runPlan[runIndex];
    patternSel.value=cur; state.pattern=cur; updateProgressUI();
    buildCourse(false);
    document.getElementById('wLabel').textContent=`${Math.round(state.corridorPx)} px`;
    try{ document.getElementById('scrW').value = screen.width||''; document.getElementById('scrH').value = screen.height||''; }catch{}
    updatePxPerCm(); setStatus('Bereit');
  });
}
init();


/* ==================== AUDITIVE ZAHLEN-SEQUENZ (DUAL-TASK) ==================== */
let currentSequence = null;
let seqPlayed = false;

/** Erstellt und spricht eine zufällige Zahlenreihe */
function playNumberSequence() {
  const len = Math.min(7, Math.max(4, parseInt(document.getElementById("seqLength").value) || 5));
  const sequence = Array.from({ length: len }, () => Math.floor(Math.random() * 10));
  currentSequence = sequence;
  seqPlayed = true;

  console.log("Sequenz:", sequence.join(" "));
  setStatus(`Zahlensequenz (${len} Zahlen) wird abgespielt …`);

  const synth = window.speechSynthesis;
  let i = 0;

  function speakNext() {
    if (i >= sequence.length) return;
    const utter = new SpeechSynthesisUtterance(String(sequence[i]));
    utter.lang = "de-DE";
    utter.rate = 0.9; // etwas langsamer
    synth.speak(utter);
    i++;
    setTimeout(speakNext, 1500); // 1,5 Sekunden Abstand
  }

  // Starte direkt (wird durch echten Klick erlaubt)
  speakNext();
}

/** Eingabeaufforderung nach Ende des Durchgangs */
function showSequenceInput() {
  if (!currentSequence) return;

  // Button finden, vor dem eingefügt werden soll
  const nextBtn = document.getElementById("nextBtn");

  // Falls schon vorhanden, nichts doppelt einfügen
  if (document.getElementById("seqInput")) return;

  const container = document.createElement("div");
  container.className = "note";
  container.style.marginTop = "16px";
  container.innerHTML = `
    <p><strong>Bitte die gehörte Zahlenfolge eingeben:</strong></p>
    <input id="seqInput" type="text" placeholder="z. B. 5738"
           style="padding:8px;border:1px solid #ccc;border-radius:8px;width:120px;margin-right:8px;" />
    <button class="btn" id="seqSubmit">Absenden</button>
  `;

  // Eingabefeld direkt *vor* dem "Nächstes Muster"-Button platzieren
  nextBtn.parentNode.insertBefore(container, nextBtn);

  document.getElementById("seqSubmit").addEventListener("click", async () => {
    const entered = document.getElementById("seqInput").value.trim();
    const correct = currentSequence.join("");
    const result = entered === correct ? "richtig" : "falsch";

    state.sequence = { correct, entered, result };
    setStatus(`Sequenz war ${result.toUpperCase()}.`);

    container.remove();
  // Kein sofortiges Senden mehr – wird erst bei "Nächstes Muster" gesendet
    currentSequence = null;
    seqPlayed = false;
  });
}

/* ------------------- Integration in bestehenden Zeichenfluss ------------------- */
const origPointerDown = cv.onpointerdown;
cv.addEventListener("pointerdown", (e) => {
  const p = canvasPosFromEvent(e);
  const tol = 12 * DPR;

  // Prüfe Startpunkt
  if (!state.started && state.start && dist(p, state.start) <= tol && !seqPlayed) {
    setTimeout(() => {
      // Erst hier darf Sprache abgespielt werden (direkt nach Nutzeraktion)
      playNumberSequence();
    }, 1000);
  }
}, true); // capture=true: läuft VOR dem anderen pointerdown-Handler

// Ergänzung nach Durchgang
cv.addEventListener("pointerup", (e) => {
  const p = canvasPosFromEvent(e);
  const tol = 12 * DPR;
  // Wenn Ziel berührt → Eingabe auffordern
  if (state.finish && dist(p, state.finish) <= tol && seqPlayed) {
    setTimeout(showSequenceInput, 800);
  }
}, false);

</script>
</body>
</html>